/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4,
maxerr: 50, node: true */
/*global require */

var Net = require("net");
var EventEmitter = require("events").EventEmitter;
var es = require("event-stream");
var ResponseParser = require("ftp-response-parser");
var ListingParser = require("parse-listing");
var util = require("util");
var fs = require("fs");
var once = require("once");

var FTP_PORT = 21;
var TIMEOUT = 10 * 60 * 1000;
var IDLE_TIME = 30000;
var NOOP = function() {};

var Ftp = function (cfg) {
    "use strict";

    Object.keys(cfg).forEach(function (opt) {
        if (!this[opt]) { this[opt] = cfg[opt]; }
    }, this);

    EventEmitter.call(this);

    this.useMLSD = this.useMLSD || false;
    this.port = this.port || FTP_PORT;
    this.pending = []; // Pending requests
    this.commandQueue = [];
    this.resParser = new ResponseParser();
    
    var self = this;
    this.on('data', function(data) {
        if (self.debugMode) {
            self.emit('jsftp_debug', 'response', data || NOOP);
        }
    });
    
    this.socket = this.createSocket({
        port: this.port,
        host: this.host
    });
    self.commandQueue.push({
        command: {cmd: "placeholder"},
        callback: function(err, data) {
        }
    });
};

util.inherits(Ftp, EventEmitter);
module.exports = Ftp;

Ftp.prototype.doCMD = function(params) {
    /*
        command
        callback
    */
    var self = this,
        doThis = function() {
            var doThis2 = function() {

            }
            if (!self.Auth) {
                self.auth({
                    user: self.user,
                    pass: self.pass,
                    callback: doThis2
                });
            } else {
                doThis2();
            }
        };
    if (!this.socket) {
        this.socket = this.createSocket({
            port: this.port,
            host: this.host,
            callback: doThis
        });
    } else {
        doThis();
    }
};
Ftp.prototype.createSocket = function(params) {
    if (this.socket && this.socket.destroy) this.socket.destroy();
    this.Auth = false;
    var socket = Net.createConnection(params.port, params.host, params.callback || NOOP);
    var self = this;
    socket.on("connect", function(data) {
        self.emit("connect", data);
    });
    socket.on("timeout", function(data) {
        self.emit("timeout", data);
    });

    this.pipeline = es.pipeline(socket, this.resParser);

    var self = this;
    this.pipeline.on('data', function(data) {
        self.parseResponse(data);
    });
    this.pipeline.on("error", function(data) {
        self.emit("connectError", {code: data.code, errno: data.errno, syscall: data.syscall});
    });

    return socket;
};
Ftp.prototype.auth = function(params) {
    if (this.authenticating) return;

    if (!params.user) params.user = "anonymous";
    if (!params.pass) params.pass = "@anonymous";

    this.authenticating = true;

    var self = this;
    self.raw({
        command: "user",
        arguments: [params.user],
        callback: function(err, data) {
            if (err || [230, 331, 332].indexOf(data.code) == -1) {
                self.authenticating = false;
                if (params.callback) {
                    params.callback(err, data);
                }
            } else {
                self.raw({
                    command: "pass",
                    arguments: [params.pass],
                    callback: function(err, data) {
                        self.authenticating = false;
                        
                        if (err || [202, 230].indexOf(data.code) == -1) {
                            if (params.callback) {
                                params.callback(err, data);
                            }
                        } else {
                            self.Auth = true;
                            self.raw({
                                command: "feat",
                                callback: function(err, data) {
                                    if (err) {
                                        self.raw({
                                            command: "help",
                                            callback: function(err, data) {
                                                if (err) {
                                                    params.callback(err, data);
                                                } else {
                                                    if (params.callback) {
                                                        params.callback(false, data);
                                                    }
                                                }
                                            }
                                        });
                                    } else {
                                        if (params.callback) {
                                            params.callback(false, data);
                                        }
                                    }
                                }
                            });
                        }
                    }
                });
            }
        }
    });
    /*self.raw.user(user, function(err, res) {
        if (!err && [230, 331, 332].indexOf(res.code) > -1) {
            self.raw.pass(pass, function(err, res) {
                self.authenticating = false;

                if (err) {
                    notifyAll(err);
                } else if ([230, 202].indexOf(res.code) > -1) {
                    self.authenticated = true;
                    self.user = user;
                    self.pass = pass;
                    self.raw.type("I", function() {
                        notifyAll(null, res);
                    });
                } else if (res.code === 332) {
                    self.raw.acct(""); // ACCT not really supported
                }
            });
        } else {
            self.authenticating = false;
            notifyAll(err);
        }
    });*/
};
Ftp.prototype.raw = function(params) {
    /*
        command
        callback
        arguments
    */
    if (!params.command) {
        if (params.callback) {
            params.callback();
        }
    }

    var commandString = params.command 
    if (params.arguments && params.arguments.length > 0) {
        commandString = commandString + " " + params.arguments.join(" ");
    }

    this.commandQueue.push({command: commandString, callback: params.callback, callback100: params.callback100});
    if (!this.inProgress) {
        this.doQueue();
    }
};
Ftp.prototype.doQueue = function() {
    if (this.commandQueue.length > 0) {
        this.inProgress = true;
        var command = this.commandQueue[0].command;

        if (command && typeof command == "string") {
            this.emit("cmdSend", command);
            this.pipeline.write(command + "\r\n");

            if (this.debugMode) {
                this.emit('jsftp_debug', 'user_command', command || {});
            }
        }
    }
};
Ftp.prototype.parseResponse = function(data) {
    if (this.debugMode) {
        this.emit('jsftp_debug', 'server_response', data || {});
    }
    if (data.code < 200) {
        if (this.commandQueue[0].callback100) {
            this.commandQueue[0].callback100(data.isError, data);
        }
    } else {
        if (this.commandQueue[0]) {
            if (this.commandQueue[0].callback) {
                this.commandQueue[0].callback(data.isError, data);
            }
            this.commandQueue.shift();
        } else {
            this.emit("customError", data);
        }
        this.inProgress = false;
        this.doQueue();
    }
};
Ftp.prototype.sendCommand = function(params) {
    var self = this;
    var doThis = function() {
        self.openPassive({
            callback: function(err, socket) {
                self.pasvSocket = socket;
                self.pasvTimeout.bind(self, socket, params.callback);
                if (params.setPause) {
                    socket.pause();
                }
                //console.log(socket);
                socket.on("data", params.onData || NOOP);
                socket.on("close", params.onClose || NOOP);
                socket.on("error", params.onError || NOOP);
                socket.on("connect", params.onConnect || NOOP);
                socket.on("readable", params.onReadable || NOOP);
                socket.on("end", params.onEnd || NOOP);
                if (params.pipe) {
                    socket.pipe(params.pipe);
                }
                if (params.pipe2) {
                    params.pipe2.pipe(socket);
                }
                if (params.resume) {
                    socket.resume();
                }
            }
        });
    }

    self.raw({
        command: "TYPE",
        arguments: ["I"],
        callback: function(err, data) {
            if (err) {
                params.callback(err, data);
            } else {
                if (params.callback) {
                    doThis();
                }
            }
        }
    });
}
Ftp.prototype.listing = "";
Ftp.prototype.ls = function(path, callback) {
    var self = this,
        command = "LIST",
        noExist = false,
        bigError = false;
    if (this.useMLSD) {
        command = "MLSD";
    }
    var commandToSend = {
        command: command,
        arguments: [(path || "/")],
        callback: function(err, data) {
            if (err && ( data.code == 550 || data.code == 450) ) {
                noExist = data;
                if (self.useMLSD) {
                    self.pasvSocket.destroy();
                } else {
                    callback(data);
                }
            }
        }
    };
    self.listing = "";
    this.sendCommand({
        callback: callback,
        onData: function(data) {
            self.listing += data;
        },
        onClose: function(err) {
            if (!bigError && !noExist) {
                var listing = self.listing;
                if (command === "LIST") {
                    if (!bigError && listing != "") {
                        ListingParser.parseFtpEntries(listing, callback);
                    }
                } else if (command === "MLSD") {
                    var l = listing.split("\r\n"),
                        ret = [];
                    l.forEach(function(o, n) {
                        var row = o.split(" "),
                            h_params = row[0].split(";"),
                            respParams = {};
                        if (row[1] && row[0]) {
                            h_params.forEach(function(p, i) {
                                var tmp = p.split("=");
                                if (tmp[0] && tmp[1]) {
                                    respParams[tmp[0]] = tmp[1];
                                }
                            });
                            if (respParams.type === "dir" || respParams.type === "file") {
                                var type = 0;
                                if (respParams.type === "dir") {
                                    type = 1;
                                }
                                var time = respParams.modify.match(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/);
                                var y = parseInt(time[1]);
                                var m = parseInt(time[2].replace(/^0/i, "")) - 1;
                                var d = parseInt(time[3].replace(/^0/i, ""));
                                var h = parseInt(time[4].replace(/^0/i, ""));
                                var mi = parseInt(time[5].replace(/^0/i, ""));
                                var s = parseInt(time[6].replace(/^0/i, ""));
                                var date = new Date(y, m, d, h, mi, s, 0);
                                var t = date.getTime();
                                ret.push({
                                    name: row[1],
                                    type: type,
                                    time: t,
                                    size: respParams.size,
                                });
                            }
                        }
                    });
                    callback(noExist, ret);
                }
            } else {
                callback(noExist);
            }
        },
        onError: function(err) {
            if (!bigError) {
                bigError = err;
                callback(err);
            }
        },
        onConnect: function() {
            self.raw(commandToSend);
        }
    });
}
Ftp.prototype.get = function(remotePath, localPath, callback) {
    var self = this;
    callback = once(callback || NOOP);
    var commandToSend = {
        command: "RETR",
        arguments: [remotePath],
        callback: function(err, data) {
            if (err) {
                callback(data);
            }
        }
    };
    
    var writeStream = fs.createWriteStream(localPath);
    writeStream.on('error', callback);
    this.sendCommand({
        callback: callback,
        onError: function(err) {
            callback(err);
        },
        onConnect: function() {
            self.raw(commandToSend);
        },
        onEnd: callback,
        setPause: true,
        onReadable: function() {
            self.emitProgress({
                filename: remotePath,
                action: 'get',
                socket: this
            });
        },
        pipe: writeStream,
        resume: true
    });
};

Ftp.prototype.put = function(from, to, callback) {
    var self = this;
    fs.exists(from, function(exists) {
        if (!exists)
            return callback(new Error("Local file doesn't exist."));

        fs.stat(from, function(err, stats) {
            var totalSize = err ? 0 : stats.size;
            if (totalSize === 0) {
                return callback(new Error("Filesize = 0. That's bad."));
            }
            var read = fs.createReadStream(from, {
                bufferSize: 4 * 1024
            });
            read.on("readable", function() {
                self.emitProgress({
                    filename: to,
                    action: "put",
                    socket: read,
                    totalSize: totalSize
                });
            });
            read.once("readable", function() {
                var commandToSend = {
                    command: "STOR",
                    arguments: [to],
                    callback: function(err, data) {
                        if (err) {
                            callback(data);
                        }
                    }
                };
                self.sendCommand({
                    callback: callback,
                    onError: function(err) {
                        callback(err);
                    },
                    onClose: function(err) {
                        callback(err);
                    },
                    onConnect: function() {
                        self.raw(commandToSend);
                    },
                    pipe2: read
                });
            });
        });
    });
};

Ftp.prototype.useCommand = function(command) {
    if (command == "MLSD") {
        this.useMLSD = true;
    }
}
Ftp.prototype.openPassive = function(params) {
    var self = this;
    self.raw({
        command: "PASV",
        callback: function(err, data) {
            var RE_PASV = /([-\d]+,[-\d]+,[-\d]+,[-\d]+),([-\d]+),([-\d]+)/;
            var match = RE_PASV.exec(data.text);
            if (!match) {
                return params.callback(new Error("Bad passive host/port combination"));
            }

            var port = (parseInt(match[2], 10) & 255) * 256 + (parseInt(match[3], 10) & 255),
                host = match[1].replace(/,/g, ".");
            var socket = Net.createConnection(port, host);
            socket.setTimeout(TIMEOUT);
            params.callback(null, socket);            
        }
    });
}

Ftp.prototype.pasvTimeout = function(socket, cb) {
    var self = this;
    socket.once('timeout', function() {
        self.emit('timeout');
        socket.destroy();
        cb(new Error("Passive socket timeout"));
    });
};

Ftp.prototype.keepAlive = function(wait) {
    var self = this;
    if (this._keepAliveInterval)
        clearInterval(this._keepAliveInterval);

    this._keepAliveInterval = setInterval(function() {
        if (!self.inProgress) {
            self.raw({
                command: "NOOP"
            });
        }
    }, wait || IDLE_TIME);
};

Ftp.prototype.emitProgress = function(data) {
    this.emit('progress', {
        filename: data.filename,
        action: data.action,
        total: data.totalSize || 0,
        chunksize: data.socket['_readableState'].length,
        transferred: data.socket[
            data.action === 'get' ? 'bytesRead' : 'bytesWritten']
    });
};

Ftp.prototype.destroy = function(callback) {
    if (this._keepAliveInterval)
        clearInterval(this._keepAliveInterval);

    this.socket.destroy();
    this.features = null;
    this.authenticated = false;
    if (callback) {
        callback();
    }
};